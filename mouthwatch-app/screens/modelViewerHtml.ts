export const getModelViewerHtml = (annotationsJSON: string, modelUri: string): string => {
  return [
    '<!DOCTYPE html>',
    '<html>',
    '<head>',
    '<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">',
    '<style>',
    '* { margin: 0; padding: 0; box-sizing: border-box; }',
    'body { background: #0a0f1e; overflow: hidden; width: 100vw; height: 100vh; }',
    'canvas { display: block; }',
    '#tooltip { position: fixed; display: none; background: #0d1321; border: 1px solid rgba(255,255,255,0.15); border-radius: 10px; padding: 10px 14px; min-width: 160px; max-width: 220px; pointer-events: none; z-index: 100; }',
    '#tooltip .severity { font-size: 10px; font-weight: 700; letter-spacing: 1px; text-transform: uppercase; margin-bottom: 4px; }',
    '#tooltip .label { color: #ffffff; font-size: 13px; font-weight: 600; margin-bottom: 3px; }',
    '#tooltip .note { color: rgba(255,255,255,0.5); font-size: 11px; line-height: 1.4; }',
    '#hint { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.25); font-size: 11px; font-family: -apple-system, sans-serif; text-align: center; pointer-events: none; }',
    '</style>',
    '</head>',
    '<body>',
    '<div id="tooltip">',
    '<div class="severity" id="tt-severity"></div>',
    '<div class="label" id="tt-label"></div>',
    '<div class="note" id="tt-note"></div>',
    '</div>',
    '<div id="hint">Drag to rotate Â· Pinch to zoom</div>',
    '<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>',
    '<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>',
    '<script>',

    'var status = document.createElement("div");',
    'status.style.cssText = "position:fixed;top:20px;left:20px;color:white;font-size:14px;font-family:sans-serif;z-index:999;background:rgba(0,0,0,0.7);padding:8px 12px;border-radius:8px;";',
    'status.textContent = "Starting...";',
    'document.body.appendChild(status);',

    'if (typeof THREE === "undefined") { status.textContent = "THREE not loaded!"; status.style.background = "red"; throw new Error("stop"); }',
    'if (typeof THREE.GLTFLoader === "undefined") { status.textContent = "GLTFLoader not loaded!"; status.style.background = "red"; throw new Error("stop"); }',

    'document.body.style.border = "4px solid green";',
    'status.textContent = "THREE ok, fetching GLB...";',

    'var annotations = ' + annotationsJSON + ';',
    'var scene = new THREE.Scene();',
    'scene.background = new THREE.Color(0x0a0f1e);',
    'var w = window.innerWidth, h = window.innerHeight;',
    'var camera = new THREE.PerspectiveCamera(35, w/h, 0.1, 100);',
    'camera.position.set(0, 0, 5);',
    'var renderer = new THREE.WebGLRenderer({ antialias: true });',
    'renderer.setSize(w, h);',
    'renderer.setPixelRatio(window.devicePixelRatio);',
    'document.body.appendChild(renderer.domElement);',
    'scene.add(new THREE.AmbientLight(0xffffff, 0.8));',
    'var dLight = new THREE.DirectionalLight(0xffffff, 1.4);',
    'dLight.position.set(3, 5, 3);',
    'scene.add(dLight);',
    'var dLight2 = new THREE.DirectionalLight(0xffffff, 0.4);',
    'dLight2.position.set(-3, -2, -2);',
    'scene.add(dLight2);',
    'var blueLight = new THREE.PointLight(0x00c2ff, 0.3);',
    'blueLight.position.set(0, 0, 3);',
    'scene.add(blueLight);',

    'var spherical = { theta: 0, phi: Math.PI/2, radius: 5 };',
    'var target = new THREE.Vector3(0, 0, 0);',
    'var isDragging = false;',
    'var prevX = 0, prevY = 0;',
    'var prevPinchDist = 0;',

    'renderer.domElement.addEventListener("touchstart", function(e) {',
    '  e.preventDefault();',
    '  if (e.touches.length === 1) {',
    '    isDragging = true;',
    '    prevX = e.touches[0].clientX;',
    '    prevY = e.touches[0].clientY;',
    '  } else if (e.touches.length === 2) {',
    '    var dx = e.touches[0].clientX - e.touches[1].clientX;',
    '    var dy = e.touches[0].clientY - e.touches[1].clientY;',
    '    prevPinchDist = Math.sqrt(dx*dx + dy*dy);',
    '  }',
    '}, { passive: false });',

    'renderer.domElement.addEventListener("touchmove", function(e) {',
    '  e.preventDefault();',
    '  if (e.touches.length === 1 && isDragging) {',
    '    var dx = e.touches[0].clientX - prevX;',
    '    var dy = e.touches[0].clientY - prevY;',
    '    spherical.theta -= dx * 0.01;',
    '    spherical.phi -= dy * 0.01;',
    '    spherical.phi = Math.max(0.2, Math.min(Math.PI - 0.2, spherical.phi));',
    '    prevX = e.touches[0].clientX;',
    '    prevY = e.touches[0].clientY;',
    '  } else if (e.touches.length === 2) {',
    '    var dx = e.touches[0].clientX - e.touches[1].clientX;',
    '    var dy = e.touches[0].clientY - e.touches[1].clientY;',
    '    var dist = Math.sqrt(dx*dx + dy*dy);',
    '    var delta = prevPinchDist - dist;',
    '    spherical.radius = Math.max(1, Math.min(12, spherical.radius + delta * 0.02));',
    '    prevPinchDist = dist;',
    '  }',
    '}, { passive: false });',

    'renderer.domElement.addEventListener("touchend", function() { isDragging = false; });',

    'function updateCamera() {',
    '  camera.position.x = target.x + spherical.radius * Math.sin(spherical.phi) * Math.sin(spherical.theta);',
    '  camera.position.y = target.y + spherical.radius * Math.cos(spherical.phi);',
    '  camera.position.z = target.z + spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta);',
    '  camera.lookAt(target);',
    '}',

    'function animate() {',
    '  requestAnimationFrame(animate);',
    '  updateCamera();',
    '  renderer.render(scene, camera);',
    '}',
    'animate();',

    'fetch("' + modelUri + '")',
    '  .then(function(res) {',
    '    status.textContent = "Response: " + res.status + " type:" + res.headers.get("content-type");',
    '    if (!res.ok) throw new Error("HTTP " + res.status);',
    '    return res.arrayBuffer();',
    '  })',
    '  .then(function(buffer) {',
    '    status.textContent = "Parsing " + buffer.byteLength + " bytes...";',
    '    var loader = new THREE.GLTFLoader();',
    '    loader.parse(buffer, "",',
    '      function(gltf) {',
    '        status.textContent = "Model loaded!";',
    '        setTimeout(function() { status.style.display = "none"; }, 2000);',
    '        var model = gltf.scene;',
    '        scene.add(model);',
    '        var box = new THREE.Box3().setFromObject(model);',
    '        var center = new THREE.Vector3();',
    '        var size = new THREE.Vector3();',
    '        box.getCenter(center);',
    '        box.getSize(size);',
    '        var maxDim = Math.max(size.x, size.y, size.z);',
    '        target.copy(center);',
    '        spherical.radius = maxDim * 1.8;',
    '        updateCamera();',
    '        annotations.forEach(function(ann) {',
    '          var group = new THREE.Group();',
    '          group.position.set(center.x + ann.position[0], center.y + ann.position[1], center.z + ann.position[2]);',
    '          var glowGeo = new THREE.SphereGeometry(0.06, 16, 16);',
    '          var glowMat = new THREE.MeshStandardMaterial({ color: ann.color, emissive: ann.color, emissiveIntensity: 0.3, transparent: true, opacity: 0.25 });',
    '          group.add(new THREE.Mesh(glowGeo, glowMat));',
    '          var coreGeo = new THREE.SphereGeometry(0.035, 16, 16);',
    '          var coreMat = new THREE.MeshStandardMaterial({ color: ann.color, emissive: ann.color, emissiveIntensity: 0.9 });',
    '          var core = new THREE.Mesh(coreGeo, coreMat);',
    '          core.userData = { annotation: ann };',
    '          group.add(core);',
    '          scene.add(group);',
    '        });',
    '      },',
    '      function(e) {',
    '        status.style.background = "rgba(255,100,0,0.9)";',
    '        status.textContent = "Parse error: " + e;',
    '      }',
    '    );',
    '  })',
    '  .catch(function(e) {',
    '    status.style.background = "rgba(255,0,0,0.9)";',
    '    status.textContent = "Fetch failed: " + e;',
    '  });',

    'window.addEventListener("resize", function() {',
    '  camera.aspect = window.innerWidth / window.innerHeight;',
    '  camera.updateProjectionMatrix();',
    '  renderer.setSize(window.innerWidth, window.innerHeight);',
    '});',
    '</script>',
    '</body>',
    '</html>',
  ].join('\n');
};